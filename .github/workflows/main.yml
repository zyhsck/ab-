name: Watch Face Generator with Auto-Cleanup and Preview Fix

on:
  repository_dispatch:
    types: [generate_watchface]
  workflow_dispatch:
    inputs:
      input_json:
        description: 'JSON containing model path and image Base64'
        required: true

jobs:
  generate:
    runs-on: windows-latest
    permissions:
      contents: write
      
    steps:
      # 1. Checkout code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Increase virtual memory
      - name: Increase virtual memory to 16GB
        run: |
          wmic computersystem set AutomaticManagedPagefile=False
          wmic pagefileset create name="C:\pagefile.sys"
          wmic pagefileset where name="C:\pagefile.sys" set InitialSize=16384,MaximumSize=16384
          wmic pagefileset list brief
          echo "Virtual memory increased to 16GB"

      # 3. Process input data
      - name: Parse input JSON
        id: parse-input
        run: |
          $inputData = if ('${{ github.event_name }}' -eq 'repository_dispatch') {
            '${{ toJson(github.event.client_payload.input_json) }}'
          } else {
            '${{ toJson(github.event.inputs.input_json) }}'
          }
          
          $jsonInput = $inputData | ConvertFrom-Json
          $jsonInput.model | Out-File "$env:RUNNER_TEMP\model_path.txt"
          $jsonInput.file | Out-File "$env:RUNNER_TEMP\image_base64.txt" -NoNewline
          
          echo "model_path_file=$env:RUNNER_TEMP\model_path.txt" >> $env:GITHUB_OUTPUT
          echo "base64_file=$env:RUNNER_TEMP\image_base64.txt" >> $env:GITHUB_OUTPUT

      - name: Prepare project directory
        id: prepare-project
        run: |
          # 设置项目目录路径
          $projectDir = "project"
          $fprjFile = "fprj.fprj"
          
          # 获取模型路径
          $modelPath = Get-Content "$env:RUNNER_TEMP\model_path.txt"
          
          # 复制模型目录结构到项目目录
          New-Item -Type Directory -Path $projectDir -Force
          $sourceTemplateDir = Split-Path $modelPath -Parent
          
          # 递归复制所有文件和文件夹
          $filesCopied = 0
          $directories = Get-ChildItem -Path $sourceTemplateDir -Recurse
          foreach ($item in $directories) {
              $relativePath = $item.FullName.Substring($sourceTemplateDir.Length + 1)
              $targetPath = Join-Path $projectDir $relativePath
              
              if ($item.PSIsContainer) {
                  New-Item -ItemType Directory -Path $targetPath -Force | Out-Null
              } else {
                  Copy-Item -Path $item.FullName -Destination $targetPath -Force
                  $filesCopied++
              }
          }
          Write-Output "Copied $filesCopied files to project directory"
          
          # 查找FPRJ文件
          $fprjFiles = @(Get-ChildItem -Path $projectDir -Filter "*.fprj" -Recurse)
          Write-Output "Found $($fprjFiles.Count) FPRJ files in project directory"
          
          # 输出目录树帮助调试
          Write-Output "Project directory structure:"
          tree $projectDir /F | Out-String -Width 1024
          
          if ($fprjFiles.Count -eq 0) {
              Write-Error "No FPRJ file found in project directory."
              exit 1
          }
          
          # 重命名第一个找到的FPRJ文件
          $fprjOriginal = $fprjFiles[0]
          $newName = $fprjFile
          $newPath = Join-Path $fprjOriginal.Directory $newName
          Rename-Item -Path $fprjOriginal.FullName -NewName $newName -Force
          Write-Output "Renamed project file: $($fprjOriginal.FullName) -> $newPath"
          
          # 保存Base64图片到正确的路径
          $base64Content = Get-Content "${{ steps.parse-input.outputs.base64_file }}" -Raw
          $bytes = [Convert]::FromBase64String($base64Content)
          
          # 获取fprj文件所在目录
          $fprjDir = Split-Path $newPath -Parent
          
          # 创建images目录（如果不存在）
          $imagesDir = Join-Path $fprjDir "images"
          New-Item -ItemType Directory -Path $imagesDir -Force
          
          # 保存背景图 - 使用更可靠的方法
          $picPath = Join-Path $imagesDir "pic.png"
          
          # 确保文件写入完成
          $stream = [System.IO.File]::Create($picPath)
          $stream.Write($bytes, 0, $bytes.Length)
          $stream.Flush()
          $stream.Close()
          
          # 保存预览图 - 使用复制而不是引用
          $prePath = Join-Path $imagesDir "pre.png"
          
          # 使用System.IO.File.Copy确保完整复制
          [System.IO.File]::Copy($picPath, $prePath, $true)
          
          Write-Output "Saved background image to: $picPath"
          Write-Output "Saved preview image to: $prePath"
          
          # 创建输出目录
          New-Item -Type Directory -Path "$projectDir\output" -Force
          
          # 输出路径变量
          echo "project_path=$projectDir" >> $env:GITHUB_OUTPUT
          echo "fprj_path=$newPath" >> $env:GITHUB_OUTPUT
          echo "preview_path=$prePath" >> $env:GITHUB_OUTPUT
      
      # 5. Set up Python with Pillow
      - name: Set up Python 3.10 and Pillow
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install Pillow for image resizing
        run: pip install Pillow

      - name: Compile Watch Face (with retry)
        id: compile-watchface
        env:
          PROJECT_PATH: "${{ steps.prepare-project.outputs.fprj_path }}"
          OUTPUT_DIR: "${{ github.workspace }}/output"
        run: |
          # 错误处理函数
          function Handle-Errors {
            param($errorOutput)
            
            # 1. 处理预览尺寸错误
            $previewPattern = 'Preview has wrong size: (\d+)x(\d+), expected: (\d+)x(\d+)'
            if ($errorOutput -match $previewPattern) {
              $expectedWidth = $Matches[3]
              $expectedHeight = $Matches[4]
              
              # 获取预览图路径
              $previewPath = "${{ steps.prepare-project.outputs.preview_path }}"
              
              # 使用Python调整图片尺寸 - 更健壮的方法
              Write-Output "Resizing preview image from $($Matches[1])x$($Matches[2]) to $expectedWidth x $expectedHeight"
              
              # 创建临时Python脚本
              $pythonScript = @"
import os
import time
from PIL import Image

def resize_image(path, width, height):
    # 检查文件是否存在
    if not os.path.exists(path):
        print(f"Error: File not found - {path}")
        return False
    
    # 尝试多次打开文件（解决文件锁定问题）
    for attempt in range(5):
        try:
            img = Image.open(path)
            print(f"Original preview size: {img.width}x{img.height}")
            img = img.resize((width, height))
            img.save(path)
            print(f"Resized preview to: {width}x{height}")
            return True
        except Exception as e:
            print(f"Attempt {attempt+1} failed: {str(e)}")
            time.sleep(0.5)  # 等待0.5秒后重试
    
    print("All attempts failed to resize image")
    return False

resize_image(r'$previewPath', $expectedWidth, $expectedHeight)
"@
              
              # 保存Python脚本
              $scriptPath = Join-Path $env:TEMP "resize_image.py"
              $pythonScript | Out-File $scriptPath -Encoding UTF8
              
              # 执行Python脚本
              python $scriptPath
              
              return $true
            }
            
            return $false
          }
          
          # 首次尝试编译
          Write-Output "First compilation attempt..."
          $output = python compile_watchface.py 2>&1 | Out-String
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -eq 0) {
            Write-Output "Compilation succeeded on first attempt"
            exit 0
          }
          
          Write-Output "Compilation output:"
          Write-Output $output
          
          # 尝试处理错误
          if (Handle-Errors $output) {
            # 重新编译
            Write-Output "Retrying compilation after fixing errors..."
            $output = python compile_watchface.py 2>&1 | Out-String
            $exitCode = $LASTEXITCODE
            
            if ($exitCode -eq 0) {
              Write-Output "Compilation succeeded after fixes"
              exit 0
            } else {
              Write-Output "Compilation failed after fixes. Output:"
              Write-Output $output
            }
          }
          
          # 最终失败处理
          Write-Output "Compilation failed after retry attempts"
          exit 1
            
      # 7. Verify output
      - name: Verify Output File
        id: verify-output
        run: |
          $outputDir = "${{ github.workspace }}/output"
          $file = Get-ChildItem $outputDir -Filter "*.face"
          if ($file) {
              echo "face_file=$($file.FullName)" >> $env:GITHUB_OUTPUT
          } else {
              Write-Error "Output file not found"
              exit 1
          }

      # 8. Create Release
      - name: Create Release
        id: create-release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        with:
          tag_name: "face-${{ github.run_id }}"
          files: ${{ steps.verify-output.outputs.face_file }}
          draft: false
          prerelease: false

      # 9. Pass release data
      - name: Store Release Data
        id: pass-data
        run: |
          echo "release_id=${{ steps.create-release.outputs.id }}" >> $env:GITHUB_OUTPUT
          echo "release_tag=face-${{ github.run_id }}" >> $env:GITHUB_OUTPUT

    outputs:
      release_id: ${{ steps.pass-data.outputs.release_id }}
      release_tag: ${{ steps.pass-data.outputs.release_tag }}

  delete_release:
    name: Auto-Delete Release
    needs: generate
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      # 1. Wait 10 minutes (using native sleep)
      - name: Wait for 10 minutes
        run: sleep 600
      
      # 2. Delete release and tag
      - name: Delete Release Assets
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        with:
          script: |
            const { release_id, release_tag } = {
              release_id: ${{ needs.generate.outputs.release_id }},
              release_tag: '${{ needs.generate.outputs.release_tag }}'
            };
            
            if (!release_id || !release_tag) {
              core.setFailed('Missing release information');
              return;
            }
            
            try {
              // Delete release
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release_id
              });
              
              // Delete tag
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${release_tag}`
              });
              
              core.info(`Successfully deleted release ${release_id} and tag ${release_tag}`);
            } catch (error) {
              if (error.status === 404) {
                core.warning('Release or tag not found (may have been already deleted)');
              } else {
                core.setFailed(`Deletion failed: ${error.message}`);
              }
            }
